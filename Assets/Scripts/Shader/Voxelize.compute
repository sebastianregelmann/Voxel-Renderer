// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Voxelize
#pragma kernel ReadBackTexture
//Struct Definitions
struct VertexPosition {
    float3 position;
};

//Input Buffers
StructuredBuffer<VertexPosition> _VertexPositionsIn;
StructuredBuffer<int> _TriangleIndicesIn;

//Global Settings
uint _TriangleCount;
uint _Resolution;
float _VoxelSize;
float3 _BoundsMin;
float3 _BoundsMax;

//ResultTexture
RWTexture3D<int> _VoxelTexture;



bool RayIntersectsTriangle(float3 rayOrigin, float3 rayDir, float3 v0, float3 v1, float3 v2)
{
    const float EPSILON = 0.0001;
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 h = cross(rayDir, edge2);
    float a = dot(edge1, h);

    if (abs(a) < EPSILON)
    return false; // Ray is parallel to triangle

    float f = 1.0 / a;
    float3 s = rayOrigin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
    return false;

    float3 q = cross(s, edge1);
    float v = f * dot(rayDir, q);
    if (v < 0.0 || u + v > 1.0)
    return false;

    float t = f * dot(edge2, q);
    if (t > EPSILON) // Intersection occurs along the ray
    return true;

    return false;
}


[numthreads(8,8,8)]
void Voxelize (uint3 id : SV_DispatchThreadID)
{
    uint3 index = uint3(id.x, id.y, id.z);

    //Early exit
    if(index.x >= _Resolution || index.y >= _Resolution || index.z >= _Resolution)
    {
        return;
    }

    //Calculate the position in 3D space
    float3 centerOffset = _VoxelSize / 2.0;
    float3 position = float3(index.xyz) * _VoxelSize + centerOffset;




    int hitCount = 0;
    float3 rayDir = float3(1, 1, 0); // + X direction

    for (uint tri = 0; tri < _TriangleCount; tri ++)
    {
        int i0 = _TriangleIndicesIn[tri * 3 + 0];
        int i1 = _TriangleIndicesIn[tri * 3 + 1];
        int i2 = _TriangleIndicesIn[tri * 3 + 2];

        float3 v0 = _VertexPositionsIn[i0].position;
        float3 v1 = _VertexPositionsIn[i1].position;
        float3 v2 = _VertexPositionsIn[i2].position;

        //Add an offset to the Vertecies
        if(_BoundsMin.x < 0 || _BoundsMin.y < 0 || _BoundsMin.z < 0)
        {
            v0 = v0 + abs(_BoundsMin);
            v1 = v1 + abs(_BoundsMin);
            v2 = v2 + abs(_BoundsMin);
        }
        if (RayIntersectsTriangle(position, rayDir, v0, v1, v2))
        {
            hitCount ++;
        }
    }

    bool inMesh = (hitCount % 2) == 1;
    _VoxelTexture[index] = inMesh ? 1 : 0;
}


RWStructuredBuffer<int> _ReadBackBuffer;

[numthreads(8,8,8)]
void ReadBackTexture (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Resolution || id.y >= _Resolution || id.z >= _Resolution) return;

    int value = _VoxelTexture[id.xyz].r;
    int index = id.x + id.y * _Resolution + id.z * _Resolution * _Resolution;
    _ReadBackBuffer[index] = value;
}
