// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Voxelize
#pragma kernel VoxelizeChunk
#pragma kernel ReadBackTexture

//Struct Definitions
struct VertexPosition {
    float3 position;
};

//Input Buffers
StructuredBuffer<VertexPosition> _VertexPositionsIn;
StructuredBuffer<int> _TriangleIndicesIn;

//Global Settings
uint _TriangleCount;
uint _Resolution;
float _VoxelSize;
float3 _BoundsMin;
float3 _BoundsMax;

//Global Settings for chunked Voxelization
uint3 _ChunkStart;
uint3 _ChunkSize;

//ResultTexture
RWTexture3D<int> _VoxelTexture;



bool RayIntersectsTriangle(float3 rayOrigin, float3 rayDir, float3 v0, float3 v1, float3 v2)
{
    const float EPSILON = 0.0001;
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 h = cross(rayDir, edge2);
    float a = dot(edge1, h);

    if (abs(a) < EPSILON)
    return false; // Ray is parallel to triangle

    float f = 1.0 / a;
    float3 s = rayOrigin - v0;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
    return false;

    float3 q = cross(s, edge1);
    float v = f * dot(rayDir, q);
    if (v < 0.0 || u + v > 1.0)
    return false;

    float t = f * dot(edge2, q);
    if (t > EPSILON) // Intersection occurs along the ray
    return true;

    return false;
}


[numthreads(8,8,8)]
void Voxelize (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _Resolution || id.y >= _Resolution || id.z >= _Resolution)
    return;

    float3 centerOffset = _VoxelSize / 2.0;
    float3 position = float3(id.xyz) * _VoxelSize + centerOffset;

    // 6 ray directions
    float3 rayDirs[6] = {
        float3(1, 0, 0),
        float3(- 1, 0, 0),
        float3(0, 1, 0),
        float3(0, - 1, 0),
        float3(0, 0, 1),
        float3(0, 0, - 1)
    };

    uint intersections[6] = {0, 0, 0, 0, 0, 0};

    int insideVotes = 0;

    for (uint tri = 0; tri < _TriangleCount; tri ++)
    {
        int i0 = _TriangleIndicesIn[tri * 3 + 0];
        int i1 = _TriangleIndicesIn[tri * 3 + 1];
        int i2 = _TriangleIndicesIn[tri * 3 + 2];

        float3 v0 = _VertexPositionsIn[i0].position;
        float3 v1 = _VertexPositionsIn[i1].position;
        float3 v2 = _VertexPositionsIn[i2].position;

        // Adjust if bounds are negative
        if(_BoundsMin.x < 0 || _BoundsMin.y < 0 || _BoundsMin.z < 0)
        {
            float3 offset = abs(_BoundsMin);
            v0 += offset;
            v1 += offset;
            v2 += offset;
        }

        for (int dir = 0; dir < 6; dir ++)
        {
            float3 rayDir = rayDirs[dir];

            if (RayIntersectsTriangle(position, rayDir, v0, v1, v2))
            {
                intersections[dir] ++;
            }
        }
    }


    // Parity check all axis
    for (int dir = 0; dir < 6; dir ++)
    {
        if ((intersections[dir] % 2) == 1)
        {
            insideVotes ++;
        }
    }

    // Majority rule: at least 3/6 say "inside"
    bool inMesh = insideVotes >= 3;
    _VoxelTexture[id.xyz] = inMesh ? 1 : 0;
}


[numthreads(8,8,8)]
void VoxelizeChunk (uint3 id : SV_DispatchThreadID)
{
    //Check if thread is in chunk size
    if(id.x >= _ChunkSize.x || id.y >= _ChunkSize.y || id.z >= _ChunkSize.z)
    {
        return;
    }


    //Check if id is in Resolution
    uint3 globalID = id.xyz + _ChunkStart;
    if(globalID.x >= _Resolution || globalID.y >= _Resolution || globalID.z >= _Resolution)
    return;

    float3 centerOffset = _VoxelSize / 2.0;
    float3 position = float3(globalID.xyz) * _VoxelSize + centerOffset;

    // 6 ray directions
    float3 rayDirs[6] = {
        float3(1, 0, 0),
        float3(- 1, 0, 0),
        float3(0, 1, 0),
        float3(0, - 1, 0),
        float3(0, 0, 1),
        float3(0, 0, - 1)
    };

    uint intersections[6] = {0, 0, 0, 0, 0, 0};

    int insideVotes = 0;

    for (uint tri = 0; tri < _TriangleCount; tri ++)
    {
        int i0 = _TriangleIndicesIn[tri * 3 + 0];
        int i1 = _TriangleIndicesIn[tri * 3 + 1];
        int i2 = _TriangleIndicesIn[tri * 3 + 2];

        float3 v0 = _VertexPositionsIn[i0].position;
        float3 v1 = _VertexPositionsIn[i1].position;
        float3 v2 = _VertexPositionsIn[i2].position;

        // Adjust if bounds are negative
        if(_BoundsMin.x < 0 || _BoundsMin.y < 0 || _BoundsMin.z < 0)
        {
            float3 offset = abs(_BoundsMin);
            v0 += offset;
            v1 += offset;
            v2 += offset;
        }

        for (int dir = 0; dir < 6; dir ++)
        {
            float3 rayDir = rayDirs[dir];

            if (RayIntersectsTriangle(position, rayDir, v0, v1, v2))
            {
                intersections[dir] ++;
            }
        }
    }


    // Parity check all axis
    for (int dir = 0; dir < 6; dir ++)
    {
        if ((intersections[dir] % 2) == 1)
        {
            insideVotes ++;
        }
    }

    // Majority rule: at least 3/6 say "inside"
    bool inMesh = insideVotes >= 3;
    _VoxelTexture[globalID.xyz] = inMesh ? 1 : 0;
}


RWStructuredBuffer<int> _ReadBackBuffer;

[numthreads(8,8,8)]
void ReadBackTexture (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Resolution || id.y >= _Resolution || id.z >= _Resolution) return;

    int value = _VoxelTexture[id.xyz].r;
    int index = id.x + id.y * _Resolution + id.z * _Resolution * _Resolution;
    _ReadBackBuffer[index] = value;
}
